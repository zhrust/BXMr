#![allow(unused)]
use std::env;
use std::fs;
use std::fs::File;
use std::fs::OpenOptions;
//use std::io::prelude::*;
use std::io::{self, Write};
use std::io::BufReader;
use std::io::BufRead;

use std::path::PathBuf;
use std::path::Path;

use std::collections::BTreeMap;

use toml::Value;
use serde::{Serialize, Deserialize};
//use envy::Error;
use itertools::Itertools;
use dotenv::dotenv;

pub const BXMC: &str = "abcdefghijklmnopqrstuvwxyz";
pub const MBCL: usize = 4; // code len.

pub const ENV_YAML: &str = "BXMR_AIM_YAML";
pub const ENV_TOML: &str = "BXMR_TEMP_TOML";

pub fn generate_strings(length: usize, 
            prefix: String, 
            gbxm: &mut BTreeMap<String, Vec<String>>
        ) {
        if length == 0 {
            return;
        }
        for c in BXMC.chars() {
            let key = prefix.clone() + &c.to_string();
            //println!("{}", key);
            gbxm.insert(key.clone(), Vec::new());
            generate_strings(length - 1, key, gbxm);
        }
    }

pub fn init2(codelen:usize) -> Option<BTreeMap<String, Vec<String>>> {
    let mut gbxm = BTreeMap::new();
    //util::generate_strings(4, String::new(), &mut gbxm);
    //generate_strings(4, String::new(), &mut gbxm);
    generate_strings(codelen, String::new(), &mut gbxm);
    println!("gen. all BXM code as {}", gbxm.len());

    Some(gbxm)
}

pub fn upd(key: &str, value: &str, gbxm: &mut BTreeMap<String, Vec<String>>) {
    if let Some(v) = gbxm.get_mut(key) {
        if v.contains(&value.to_owned()) {
            println!("{} already exists in {:?}", value, key);
        } else {
            //v.push(value.to_owned());
            v.insert(0, value.to_owned());
            println!("Updated {} in {:?}", value, key);
        }
    } else {
        gbxm.insert(key.to_owned(), vec![value.to_owned()]);
        println!("Added {} to {:?}", value, key);
    }
}

pub fn print_gbxm_sorted(gbxm: &BTreeMap<String, Vec<String>>) {
    let mut sorted_keys: Vec<&String> = gbxm.keys().collect();
    sorted_keys.sort();

    let stdout = io::stdout(); // get the global stdout entity
    let mut handle = stdout.lock(); // acquire a lock on it

    for key in sorted_keys {
        let values = gbxm.get(key).unwrap();
        //println!("{} -> {:?}", key, values);
        writeln!(handle, 
            "{} -> {:?}", key, values
        ); // add `?` if you care about errors here
    }

}











/* 
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Config {
    bxmr_aim_yaml: String,
    bxmr_temp_toml: String,
}

pub fn envy_chk() -> Result<(), Error> {
    //let config: Config = envy::from_env()?;
    //println!("bxmr_aim_yaml: {}", config.bxmr_aim_yaml);

    let config: Config = envy::from_env().unwrap_or_else(|err| match err {
        Error::MissingValue(var) => {
            eprintln!("missing environment variable: {}", var);
            std::process::exit(1);
        }
        _ => panic!("{}", err),
    });

    println!("{}", config.bxmr_aim_yaml);

    Ok(())
}

pub fn envy_upd(key: &str, value: &str) -> Result<(), Error> {
    env::set_var(key, value);
    Ok(())
}


pub fn settings() -> Value{
    let settings_str = fs::read_to_string("src/_settings.toml").unwrap();
    let settings: Value = settings_str.parse().unwrap();

    settings
}


// 检查环境变量是否存在
pub fn env_chk(key: &str) -> Option<String> {
    match env::var(key) {
        Ok(val) => Some(val),
        Err(_) => None,
    }
}

// 更新或追加环境变量的值
pub fn env_upd(key: &str, value: &str) {
    println!("append|update ENV set {}={}",key,value);
    env::set_var(key, value);
}

pub fn ok_denv() -> Result<&'static Path, String> {
    let path = Path::new(".env");
    if !path.exists() {
        let mut file = match File::create(&path) {
            Ok(file) => file,
            Err(e) => return Err(format!("Could not create .env file: {}", e)),
        };
        if let Err(e) = writeln!(file, "# Autogenerated by program") {
            return Err(format!("Could not write to .env file: {}", e));
        }
    }
    Ok(path)
}

pub fn settings() -> Value{
    let settings_str = fs::read_to_string("src/_settings.toml").unwrap();
    let settings: Value = settings_str.parse().unwrap();

    settings
}


*/



pub fn ok_denv() -> Result<&'static Path, String> {
    // 获取应用程序的执行路径
    let exe_path = env::current_exe().map_err(|e| e.to_string())?;

    // 获取执行路径的父路径
    let exe_dir = exe_path.parent().ok_or_else(|| "Failed to get parent directory".to_string())?;

    // 构造 .env 文件路径
    let mut env_path = PathBuf::from(exe_dir);
    env_path.push(".env");


    // 如果 .env 文件不存在，创建一个空的
    if !env_path.exists() {
        let mut file = File::create(&env_path).map_err(|e| e.to_string())?;
        file.write_all(b"").map_err(|e| e.to_string())?;
    }

Ok(Box::leak(env_path.into_boxed_path()))
/* 
    if env_path.exists() {
        Ok(Box::leak(env_path.into_boxed_path()))
    } else {
        let mut file = File::create(&env_path).map_err(|e| e.to_string())?;
        Ok(Box::leak(env_path.into_boxed_path()))
    }
 */
}

/*

    //Ok(env_path.as_path())

    if env_path.exists() {
        Ok(env_path.as_path())
    } else {
        File::create(&env_path).map_err(|e| e.to_string())?;
        Ok(env_path.as_path())
    }

这是因为 env_path 是一个局部变量，它的生命周期与 ok_denv() 函数相同。如果将它的引用作为函数的返回值，会导致引用返回的变量已经被释放的问题。

为了解决这个问题，可以使用 Box<Path> 类型来将 Path 对象从堆上分配出来，并在函数返回时将其所有权移动到调用方。


pub fn chk_denv(key: &str) {
    dotenv::dotenv().ok();

    match env::var(key) {
        Ok(_) => {
            match env::var(key) {
                Ok(val) => println!("{}={}", key, val),
                Err(_) => println!("{} is not set in .env file", key),
            }
        }
        Err(e) => println!("{}", e),
    }
}
pub fn chk_denv(key: &str) {
    match ok_denv() {
        Ok(env_path) => {
            if let Err(e) = dotenv::from_path(env_path) {
                eprintln!("Failed to load .env file: {}", e);
            } else {
                match env::var(key) {
                    Ok(val) => println!("{}={}", key, val),
                    Err(_) => println!("{} is not set in .env file", key),
                }
            }
        }
        Err(e) => println!("{}", e),
    }
}


pub fn rmitem_denv(key: &str) {
    match ok_denv() {
        Ok(path) => {
            let path = path.to_str().unwrap();
            let mut new_lines = String::new();
            let file = File::open(path);
            if let Ok(f) = file {
                let reader = BufReader::new(f);
                for line in reader.lines() {
                    if let Ok(l) = line {
                        if !l.starts_with(&format!("{}=", key)) {
                            new_lines.push_str(&l);
                            new_lines.push('\n');
                        }
                    }
                }
            }
            let mut file = File::create(path).unwrap();
            file.write_all(new_lines.as_bytes()).unwrap();
        }
        Err(e) => println!("{}", e),
    }
}


pub fn upd_denv(key: &str, val: &str) {
    match ok_denv() {
        Ok(path) => {
            let path = path.to_str().unwrap();
            let mut new_lines = String::new();
            let mut found_key = false;
            let file = File::open(path);
            if let Ok(f) = file {
                let reader = BufReader::new(f);
                for line in reader.lines() {
                    if let Ok(l) = line {
                        if l.starts_with(&format!("{}=", key)) {
                            found_key = true;
                            new_lines.push_str(&format!("{}={}\n", key, val));
                            print!(".env item upgrad:{}={}\n", key, val)
                        } else {
                            new_lines.push_str(&l);
                            new_lines.push('\n');
                        }
                    }
                }
            }
            if !found_key {
                new_lines.push_str(&format!("{}={}\n", key, val));
                print!("new .env item, insert:{}={}\n", key, val)
            }
            let mut file = File::create(path).unwrap();
            file.write_all(new_lines.as_bytes()).unwrap();
        }
        Err(e) => println!("{}", e),
    }
}

pub fn upd_denv(key: &str, val: &str) {
    match ok_denv() {
        Ok(path) => {
            let path = path.to_str().unwrap();
            let mut new_lines = String::new();
            let mut found_key = false;
            let file = File::open(path);
            if let Ok(f) = file {
                let reader = BufReader::new(f);
                for line in reader.lines() {
                    if let Ok(l) = line {
                        if l.starts_with(&format!("{}=", key)) {
                            found_key = true;
                            new_lines.push_str(&format!("{}={}\n", key, val));
                            print!(".env item upgrad:{}={}\n", key, val)
                        } else {
                            new_lines.push_str(&l);
                            new_lines.push('\n');
                        }
                    }
                }
            }
            if !found_key {
                new_lines.push_str(&format!("{}={}\n", key, val));
                print!("new .env item, insert:{}={}\n", key, val)
            }
            let mut file = File::create(path).unwrap();
            file.write_all(new_lines.as_bytes()).unwrap();
        }
        Err(e) => println!("{}", e),
    }
}

*/
pub fn upd_denv(key: &str, val: &str) {
    match ok_denv() {
        Ok(path) => {
            let path_str = path.to_str().unwrap();
            let mut new_lines = String::new();
            let mut found_key = false;
/* 
            // Check if .env file exists, create it if it doesn't
            let file = match File::open(path_str) {
                Ok(f) => f,
                Err(_) => {
                    match File::create(path_str) {
                        Ok(f) => f,
                        Err(_) => {
                            println!("Failed to create .env file");
                            return;
                        }
                    }
                }
            };
             */
            let file = File::open(path_str);
            let reader = BufReader::new(file.unwrap());
            for line in reader.lines() {
                if let Ok(l) = line {
                    if l.starts_with(&format!("{}=", key)) {
                        found_key = true;
                        new_lines.push_str(&format!("{}={}\n", key, val));
                        println!("Updated .env item:\n\t {}={}", key, val);
                    } else {
                        new_lines.push_str(&l);
                        new_lines.push('\n');
                    }
                }
            }

            // If the key doesn't exist in the .env file, add it
            if !found_key {
                new_lines.push_str(&format!("{}={}\n", key, val));
                println!("New .env item, inserted:\n\t {}={}", key, val);
            }

            let mut file = match File::create(path_str) {
                Ok(f) => f,
                Err(_) => {
                    println!("Failed to create .env file");
                    return;
                }
            };

            file.write_all(new_lines.as_bytes()).unwrap();
        },
        Err(e) => println!("{}", e),
    }
}


pub fn reload_denv(f2denv:&str){
    // 加载 .env 文件中的配置项
    //dotenv().ok();
    dotenv::from_path(&f2denv).ok();
    // 遍历当前进程中的所有环境变量，打印每个键值对
    //for (key, value) in std::env::vars() {
    //    println!("{}={}", key, value);
    //}
}
/* 
pub fn chk_denv(key: &str) {
    match (ok_denv(), env::var(key)) {
        (Ok(f2denv), Ok(val)) => {
            let f2denv = ok_denv().unwrap().to_str().unwrap();
            println!("load .env <-{}", f2denv);
            reload_denv(f2denv);
            println!("{}={}", key, val);
            //let f2denv = ok_denv().unwrap().to_str().unwrap();
            //list_denv(f2denv);
        },
        (Ok(f2denv), Err(_)) => {
            let f2denv = ok_denv().unwrap().to_str().unwrap();
            println!("load .env <-{}", f2denv);
            reload_denv(f2denv);
            println!("{} is not set in .env file", key);
            //list_denv(f2denv);
        },
        (Err(e), _) => println!("{}", e),
    }
}
*/

pub enum EnvResult {
    Success(String, String),
    Failure(String),
}

pub fn chk_denv(key: &str)-> EnvResult {
    match ok_denv() {
        Ok(f2denv) => {
            let f2denv = ok_denv().unwrap().to_str().unwrap();
            println!("load .env <-{}", f2denv);
            dotenv::from_path(&f2denv).ok();
            //let val = std::env::var(key);

            match std::env::var(key) {
                Ok(val) => {
                    println!("{}={}", key, val);
                    EnvResult::Success(key.to_owned(), val)
                },
                Err(_) => {
                    println!("{} is not set in .env file", key);
                    EnvResult::Failure(format!("{} is not set in .env file", key))
                }
            }
            //if let Ok(env_val) = std::env::var(key){
            //    println!("{}={}", key, env_val);
            //}else{
            //    println!("{} is not set in .env file", key);
            //}
            //let f2denv = ok_denv().unwrap().to_str().unwrap();
            //list_denv(f2denv);
        },
        Err(e) => EnvResult::Failure(e.to_string()),
        //println!("{}", e),
    }
}

pub fn rmitem_denv(key: &str) {
    match ok_denv() {
        Ok(path) => {
            let path_str = path.to_str().unwrap();
            let file = File::open(path_str);
            match file {
                Ok(f) => {
                    let reader = BufReader::new(f);
                    let lines: Vec<String> = reader.lines().filter_map(|line| line.ok()).collect();

                    let new_lines = lines
                            .iter()
                            .filter(|line| !line.starts_with(
                                &format!("{}=", key)))
                            .join("\n");

                    let mut file = File::create(path_str).unwrap();
                    file.write_all(new_lines.as_bytes()).unwrap();
                    println!("from .env removed item:\n\t {}", key);

                },
                Err(_) => println!("Failed to open .env file")
            }
        },
        Err(e) => println!("{}", e),
    }
}
